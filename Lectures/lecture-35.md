
# Lecture 35 [Frontend 8] - JSON to JSX | Importance of Structuring Data

%[https://youtu.be/rp97rUwOcjs]

## Introduction

In today's class, we will discuss how data engineering can be done in React or frontend applications. We know that to create a frontend application, data needs to be managed very well. We need to understand the difference between modern applications and old applications. In old applications, there wasn't much work with data. Data used to render from the server and display in front of us. But in modern applications, like on Facebook, if you hover over reactions, many reactions appear in front of us, we c...

But the question is, on what logic will I define this data? It's very simple. First, we need to determine what purpose the data we want to create or store somewhere will serve. Some data will remain static forever. Again, some data will update based on various functionalities. Based on this work, we can define the shape of our data. Sometimes it may happen that data is coming from the backend in one form, but the shape of the data on the frontend is entirely different. Why does this happen? Because the ...

After that, we need to keep in mind how much access the data we are designing will have. That is, will it be accessed once or will it need to be accessed repeatedly for update or delete tasks? We need to keep these things in mind.

The third thing to keep in mind is whether the data model we will create will be updated from the server at once and remain static or if we need to update it repeatedly.

Considering these aspects, the shape of data is mainly designed in frontend development. It may or may not match the backend. The main content will always be the same, but we may need to add some additional properties as needed.

The main challenge for frontend developers is data engineering or data modeling. Because it is very complex. It is very difficult to understand the behavior of data just by looking at the UI. Different features may require different extra properties. It is very difficult. But if this work can be done properly, frontend development becomes much easier. Whether it is done with React, Vue, Angular, the main thing is data engineering.

In the traditional way, HTML, CSS was generated by looking at a UI. But in the modern way, we will generate HTML, CSS by looking at the data or JSON. This is our responsibility as frontend developers.

## Working with form

First, we need to understand how to get JSON from HTML. To understand that, let's try to create a very simple form.

```jsx
// App.jsx

import React from 'react';

const App = () => {
	return (
		<form>
			<div>
				<label htmlFor="name">What is your name?</label>
				<input type="text" name="name" placeholder="John Doe" />
			</div>
			<div>
				<label htmlFor="email">What is your email?</label>
				<input type="email" name="email" placeholder="john@example.com" />
			</div>
			<div>
				<label htmlFor="phone">What is your phone number?</label>
				<input type="tel" name="phone" placeholder="+8801711111111" />
			</div>
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};

export default App;
```

When we run our application, our UI will look like this -

![ui-01.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659938394974/JqrL4-Xe7.png align="center")

Now this form is not under our control. That means we cannot handle each state of it. If we submit with incorrect data, the page will refresh. This is not a standard behavior for React or frontend applications. So we need to block the submit button first.

To block it, let's create a handle function at the beginning and attach it to the form tag.

```jsx
const App = () => {
	const handleSubmit = (event) => {
		event.preventDefault();
		console.log(event);
	};

	return (
		<form onSubmit={handleSubmit}>
			<div>
				<label htmlFor="name">What is your name?</label>
				<input type="text" name="name" placeholder="John Doe" />
			</div>
			<div>
				<label htmlFor="email">What is your email?</label>
				<input type="email" name="email" placeholder="john@example.com" />
			</div>
			<div>
				<label htmlFor="phone">What is your phone number?</label>
				<input type="tel" name="phone" placeholder="+8801711111111" />
			</div>
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};

export default App;
```

By doing this, we will see that our page is no longer refreshing. That means we have blocked the submit.

Here `preventDefault` means that we have prevented the default behavior that the browser has given to this form. For example, when you click the submit button, the browser automatically refreshes. We used `preventDefault` to stop this refresh.

Now if we try to log the event to the console to see what is there, we will see something called `SyntheticBaseEvent`. React DOM has given the JavaScript DOM event a new name, which is `SyntheticBaseEvent`. Inside it, there is a property called `target`. Inside it, we will find all our input values. Look at the marked parts in the images below.

![event-01.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659939497916/bytdSNDlh.png align="center")

![event-02.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659939511876/8HGxjuLBM.png align="center")

![event-03.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659939525309/l0QL5s8FV.png align="center")

That means we can also extract our input values if we want. How? By going inside SyntheticBaseEvent and accessing the target with index numbers, we will get the values.

If we now write `console.log(event.target[0])` inside our `handleSubmit` and log it to the console, let's see what we get.

![event-04.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659940577237/TuOzTlb5E.png align="left")

We see the HTML of our first input has come. Now if we write `console.log(event.target[0].value)`, `console.log(event.target[1].value)`, and `console.log(event.target[2].value)` in our handle function, let's see what we get in the console.

![event-05.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659940763489/ITXtG3-4M.png align="left")

We see the values of our inputs have come.

But we are not controlling these values; the browser is controlling how to handle them. We will call these forms uncontrolled forms because we have no control over them. If we want to control our form, we will forget about the target. We will define our own state, which will have our variables.

First, let's define a state.

```jsx
const [formStates, setFormStates] = useState({
	name: '',
	email: '',
	phone: '',
});
```

Now we will pass these default values of the state as values inside our form inputs.

```jsx
<input type="text" name="name" placeholder="John Doe" value={formStates.name} />
```

```jsx
<input
	type="email"
	name="email"
	placeholder="john@example.com"
	value={formStates.email}
/>
```

```jsx
<input
	type="tel"
	name="phone"
	placeholder="+8801711111111"
	value={formStates.phone}
/>
```


Now if we go to the browser and try to write in our input, we will see that we can't write anything. Because as soon as we define the state, the browser has handed over control of this form to us. Now we can update this form however we want. That is, we have full control. This is now a controlled form. But we are not able to update. So how will we control this form? We need to understand why we can't update. Since the control is in our hands, we also need to tell it what will happen if something new is...

Our state has the default value as an empty string. Now it is not updating. Since it is not updating, no matter what we write, it is always getting an empty string. We can solve this problem by using our custom handler. We need to remember that when we bind the value of any input field with our own value, it will come under our control. For that, we need to tell how the value will change when the user types. We can easily do that through `onChange`.

Let's create a custom change handler function.

```jsx
const handleChange = (event) => {
	setFormStates({
		...formStates,
		[event.target.name]: event.target.value,
	});
};
```

Now let's pass this function to all the input tags in the onChange.

```jsx
<input
	type="text"
	name="name"
	placeholder="John Doe"
	value={formStates.name}
	onChange={handleChange}
/>
```

```jsx
<input
	type="email"
	name="email"
	placeholder="john@example.com"
	value={formStates.email}
	onChange={handleChange}
/>
```

```jsx
<input
	type="tel"
	name="phone"
	placeholder="+8801711111111"
	value={formStates.phone}
	onChange={handleChange}
/>
```

Now if we go to the browser, we will see that we can update our data again.

Now if we log `formStates` in our `handleSubmit` function, we will see that our input data has come into the object of formStates.

![event-06.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659945040445/Tm1qDEdz9.png align="left")

Now we have a JSON. Now let's see how we can create this form from JSON.

## JSON to JSX

In our dynamic application, let's assume we need to render the form data we receive. That is, we have a JSON from which we need to generate such a form. How can we shape this data? This is what we will discuss today.

Let's assume we have a JSON like below.

```json
{
	"name": "",
	"email": "",
	"phone": ""
}
```

Now we need to create the form from this. Then we need to understand what can be in an input field. If we analyze our form, we will see that there are many properties in the input field. So our data type in the JSON will not be a string, it will be an object. First, we will take the label as the first property of the name. `"label": "What is your name?"`. Then we will take the type property. The type will be different for name, email, and phone number. So we need to add this here as well `"type": "text"`....

```json
{
	"name": {
		"label": "What is your name?",
		"type": "text",
		"placeholder": "John Doe"
	},
	"email": {
		"label": "What is your email?",
		"type": "email",
		"placeholder": "john@example.com"
	},
	"phone": {
		"label": "What is your phone number?",
		"type": "tel",
		"placeholder": "+8801711111111"
	}
}
```

The JSX we wrote previously for the form and this JSON are equivalent. If two things are equivalent, we can easily convert one into the other. Now a question may arise in our minds, why should we bother with JSON when we have a nice JSX format? The reason is that HTML, JSX, etc. are XML formats. And processing data in XML type format is very complex and difficult. Automating these data is very difficult. In that case, we can easily automate our JSON format. For example, if we imagine our JSON object as an...

```json
[
	{
		"name": "name",
		"label": "What is your name?",
		"type": "text",
		"placeholder": "John Doe"
	},
	{
		"name": "email",
		"label": "What is your email?",
		"type": "email",
		"placeholder": "john@example.com"
	},
	{
		"name": "phone",
		"label": "What is your phone number?",
		"type": "tel",
		"placeholder": "+8801711111111"
	}
]
```

Then we will get an advantage. That is, we can loop. Now what advantage will we get by looping? Assume there are three input fields here. Now if ten more input fields are added in a few days, then 25 more after a few days. If we keep writing code in JSX repeatedly, it will be very difficult. The biggest thing is that our dynamic concept will not be here anymore. Now assume we kept this JSON in our server. We just ran a loop in our code. Now no matter how many fields are added, we will not have to touch th...

Let's create a component named DynamicForm.jsx. And import it into our app file.

```jsx
const formFields = {
	name: {
		label: 'What is your name?',
		type: 'text',
		placeholder: 'John Doe',
	},
	email: {
		label: 'What is your email?',
		type: 'email',
		placeholder: 'john@example.com',
	},
	phone: {
		label: 'What is your phone number?',
		type: 'tel',
		placeholder: '+8801711111111',
	},
};

const DynamicForm = () => {
	return <div>DynamicForm</div>;
};

export default DynamicForm;
```

Now first, let's convert our object to an array. Let's see how it can be done.


### Convert Object to Array

Our first task is to convert the object to an array. For that, let's create a function and log it to the console.

```jsx
const mapObjectToArray = (obj) => {
	return Object.keys(obj).map((key) => ({ name: key, ...obj[key] }));
};

console.log(mapObjectToArray(formFields));
```

![json-01.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659951437220/kBpbEMrtg.png align="left")

If we look in the browser, we will see that we have got the exact array we needed.

Now let's see how we can create the form dynamically.

```jsx
const DynamicForm = () => {
	const formData = mapObjectToArray(formFields);

	return (
		<form>
			{formData.map((item, index) => (
				<div key={index}>
					<label htmlFor={item.name}>{item.label}</label>
					<input
						type={item.type}
						name={item.name}
						placeholder={item.placeholder}
					/>
				</div>
			))}
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};
```

Now if we go to our browser, we will see that our three fields have been created. If we inspect in Devtools, we will see that three divs have been created dynamically.

![json-02.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659953044302/Plgq_5ryf.png align="left")

What will happen if we add another field to our object? We will not touch our JSX code. We will just add the field below to the object.

```json
password: {
  label: 'What is your password?',
  type: 'password',
  placeholder: '******',
},
color: {
  label: 'What is your color?',
  type: 'color',
  placeholder: 'red',
},
```

Now if we go to the browser, we will see that our fields have been added.

![json-03.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659953525402/ICa5VFmLZ.png align="center")

Hopefully, by now you understand why data is so important in frontend development.

Our app is still not workable. To make it workable, we need to add some additional properties to each object. What are those? What should we do to make it workable like our previous form? We need the value property. Where do we need this value property? When we mapped the object, we need this value property. But there is a problem here. Our `mapObjectToArray` function returns an array. We created our form from this array. Now to make this form workable, we need to add `value` and `onChange` to each prop...

Backend and frontend data shapes may not match. The backend will provide whatever is needed to render the form. Now it is the frontend developer's responsibility to make it workable. So our work steps in this case are -

- **Step-1** - Transform the object as needed. We can create a function for that. Since we don't want an array, we will not use the `map` method. We will use the `reduce` method.

```jsx
const mapObjectToArray = (obj) => {
	return Object.keys(obj).reduce((acc, cur) => {
		acc[cur] = {
			...obj[cur],
			value: '',
		};
		return acc;
	}, {});
};
```

If we log this to the console, we will see that we have got an object.

![json-04.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659962652679/GLKDkT_bq.png align="left")

Here, look, the value has been newly added to each property of the object. If you are confused about the `reduce` method, read this [article](https://stacklearner.com/lecture-5-array-operations-imperative-vs-declarative-and-lecture-6-javascript-array-and-object-deep-dive-full-stack-army#heading-reduce).

Now we can keep this object in our state. Let's create our state. We will pass that state as an argument to our mapObjectToArray function. See the code below.

```jsx
const DynamicForm = () => {
	const [formState, setFormState] = useState(transformObject(formFields));
	const formData = mapObjectToArray(formState);

	return (
		<form>
			{formData.map((item, index) => (
				<div key={index}>
					<label htmlFor={item.name}>{item.label}</label>
					<input
						type={item.type}
						name={item.name}
						placeholder={item.placeholder}
						value={item.value}
					/>
				</div>
			))}
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};
```

Now if we go to our browser, we will see that we can no longer type. Because we have bound the value to our input field.

But when we submit, it is refreshing. That means our submit button is still not bound. We will copy the previous handleSubmit function and put it in onSubmit.

```jsx
const DynamicForm = () => {
	const [formState, setFormState] = useState(transformObject(formFields));
	const formData = mapObjectToArray(formState);

	const handleSubmit = (event) => {
		event.preventDefault();
		console.log(formState);
	};

	return (
		<form onSubmit={handleSubmit}>
			{formData.map((item, index) => (
				<div key={index}>
					<label htmlFor={item.name}>{item.label}</label>
					<input
						type={item.type}
						name={item.name}
						placeholder={item.placeholder}
						value={item.value}
					/>
				</div>
			))}
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};
```


Now if we click on the submit button, the whole object will come to us.

![json-05.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659963954906/yxEBAeBGV.png align="left")

But we don't need the whole object. We only need its value. So let's refine our `handleSubmit` function a bit.

```jsx
const handleSubmit = (event) => {
	event.preventDefault();
	const values = Object.keys(formState).reduce((acc, cur) => {
		acc[cur] = formState[cur].value;
		return acc;
	}, {});

	console.log(values);
};
```

Now if we go to our browser and click on the submit button, we will see that our values are coming.

![json-06.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659964333152/fEVaWRpTO.png align="left")

Now we need to create our `handleChange` function. Let's create it.

```jsx
const DynamicForm = () => {
	const [formState, setFormState] = useState(transformObject(formFields));
	const formData = mapObjectToArray(formState);

	const handleSubmit = (event) => {
		event.preventDefault();
		const values = Object.keys(formState).reduce((acc, cur) => {
			acc[cur] = formState[cur].value;
			return acc;
		}, {});

		console.log(values);
	};

	const handleChange = (event) => {
		setFormState({
			...formState,
			[event.target.name]: {
				...formState[event.target.name],
				value: event.target.value,
			},
		});
	};

	return (
		<form onSubmit={handleSubmit}>
			{formData.map((item, index) => (
				<div key={index}>
					<label htmlFor={item.name}>{item.label}</label>
					<input
						type={item.type}
						name={item.name}
						placeholder={item.placeholder}
						value={item.value}
						onChange={handleChange}
					/>
				</div>
			))}
			<div>
				<button type="submit">Submit</button>
			</div>
		</form>
	);
};
```

Now let's go to the browser and see if we can submit our form, meaning if we can update it.

![json-07.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659965153663/zLViQ3kmK.png align="left")

Wow! Our form is now fully dynamic.

Now if we need to add any field, we will only add it to our object. We will not touch our component.

Assume we want to add a birth date. Then we will just add it to our object.

```js
const formFields = {
	name: {
		label: 'What is your name?',
		type: 'text',
		placeholder: 'John Doe',
	},
	email: {
		label: 'What is your email?',
		type: 'email',
		placeholder: 'john@example.com',
	},
	phone: {
		label: 'What is your phone number?',
		type: 'tel',
		placeholder: '+8801711111111',
	},
	password: {
		label: 'What is your password?',
		type: 'password',
		placeholder: '******',
	},
	color: {
		label: 'What is your color?',
		type: 'color',
		placeholder: 'red',
	},
	birthday: {
		label: 'What is your birth date?',
		type: 'date',
		placeholder: '1-1-2022',
	},
};
```

Now if we go to the browser, we will see that it has been added.

![json-08.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659965655138/VqToawyTq.png align="left")

Now if we want to add age, we can do that in the same way.

```js
const formFields = {
	name: {
		label: 'What is your name?',
		type: 'text',
		placeholder: 'John Doe',
	},
	email: {
		label: 'What is your email?',
		type: 'email',
		placeholder: 'john@example.com',
	},
	phone: {
		label: 'What is your phone number?',
		type: 'tel',
		placeholder: '+8801711111111',
	},
	password: {
		label: 'What is your password?',
		type: 'password',
		placeholder: '******',
	},
	color: {
		label: 'What is your color?',
		type: 'color',
		placeholder: 'red',
	},
	birthday: {
		label: 'What is your birth date?',
		type: 'date',
		placeholder: '1-1-2022',
	},
	age: {
		label: 'What is your age?',
		type: 'number',
		placeholder: '20',
	},
};
```

![json-09.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1659966029871/evN1DjTc4.png align="left")


Hopefully, you understand how awesome a library React is.

So, as you can see, data engineering is the main thing in frontend development. Once this thing is mastered, frontend development becomes much easier. Normally everyone thinks designing a webpage with HTML and CSS is frontend. But the point of this lecture was to show that frontend is not just that. Logic is also required here, data handling is also needed here. We need to master this concept.

## Source Code

You can find all the source code for this lecture at this [link](https://github.com/mrhm-dev/full-stack-army/tree/master/src/lecture-35).
